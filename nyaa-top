#!/usr/bin/env python3
# Show top torrents from Sukebei.Nyaa.si sorted by seeds
# Usage: nyaa-top [--limit N] [--category cat] [--select] [--add]
# If --select is used, you can input a number to get magnet or add to aria2

import argparse
import json
import sys
import requests
from bs4 import BeautifulSoup

# Fix Telegram's em-dash substitution and accept single dash for convenience
# Convert —limit, -limit → --limit; —category → --category; etc.
normalized = []
for arg in sys.argv[1:]:
    if arg in ('—limit', '-limit'):
        normalized.append('--limit')
    elif arg in ('—category', '-category'):
        normalized.append('--category')
    elif arg in ('—select', '-select'):
        normalized.append('--select')
    elif arg in ('—add', '-add'):
        normalized.append('--add')
    else:
        normalized.append(arg)
sys.argv = [sys.argv[0]] + normalized

BASE_URL = "https://sukebei.nyaa.si/"

CATEGORY_MAP = {
    "all": "0_0",
    "anime": "1_1",
    "anime_raw": "1_2",
    "anime_non_translated": "1_3",
    "audio": "2_1",
    "lit": "3_1",
    "pics": "4_1",
    "software": "5_1",
}

def html_size_to_bytes(size_str):
    try:
        parts = size_str.strip().split()
        if len(parts) < 2: return 0
        num = float(parts[0].replace(',', ''))
        unit = parts[1].upper()
        mul = {'B':1,'KB':1024,'MB':1024**2,'GB':1024**3,'TB':1024**4,
               'KIB':1024,'MIB':1024**2,'GIB':1024**3,'TIB':1024**4}.get(unit,1)
        return int(num * mul)
    except: return 0

def fetch_top(category="anime", limit=20):
    params = {"c": CATEGORY_MAP.get(category, "1_1"), "s": "seeders", "o": "desc", "p": 0}
    try:
        r = requests.get(BASE_URL, params=params, timeout=10)
        r.raise_for_status()
        soup = BeautifulSoup(r.text, 'html.parser')
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    table = soup.find("table", {"class": "torrent-list"})
    if not table:
        print("Error: torrent list not found", file=sys.stderr)
        sys.exit(1)

    rows = table.find("tbody").find_all("tr")[:limit]
    torrents = []
    for row in rows:
        cols = row.find_all("td")
        if len(cols) < 8: continue
        title_link = row.find("a", href=lambda h: h and h.startswith("/view/") and '#' not in h)
        title = title_link.get_text(strip=True) if title_link else ""
        magnet_link = row.find("a", href=lambda h: h and h.startswith("magnet:"))
        magnet = magnet_link["href"] if magnet_link else ""
        size_str = cols[3].get_text(strip=True)
        seeds = int(cols[5].get_text(strip=True) or 0)
        leeches = int(cols[6].get_text(strip=True) or 0)
        downloads = int(cols[7].get_text(strip=True) or 0)
        torrents.append({
            "title": title,
            "magnet": magnet,
            "size": html_size_to_bytes(size_str),
            "size_str": size_str,
            "seeds": seeds,
            "leeches": leeches,
            "downloads": downloads,
        })
    # Already sorted by seeds descending from query
    return torrents

def parse_size(size_str):
    """Convert 1.2 GiB, 500M, etc to bytes. Supports: K, M, G, T (both decimal and binary)."""
    size_str = size_str.strip().upper()
    if not size_str:
        return 0
    # If already a number (unlikely), assume bytes
    if size_str.isdigit():
        return int(size_str)
    # Extract numeric part and unit
    num = ""
    unit = ""
    for char in size_str:
        if char.isdigit() or char == '.':
            num += char
        else:
            unit += char
    unit = unit.strip()
    try:
        num = float(num)
    except:
        return 0
    # Normalize unit
    if unit in ('B', ''):
        mul = 1
    elif unit in ('K', 'KB', 'KIB'):
        mul = 1024
    elif unit in ('M', 'MB', 'MIB'):
        mul = 1024**2
    elif unit in ('G', 'GB', 'GIB'):
        mul = 1024**3
    elif unit in ('T', 'TB', 'TIB'):
        mul = 1024**4
    else:
        mul = 1
    return int(num * mul)

def main():
    parser = argparse.ArgumentParser(description="List top torrents from Sukebei.Nyaa.si sorted by seeds")
    parser.add_argument("--limit", type=int, default=15, help="Number of results to show (default: 15)")
    parser.add_argument("--category", default="anime", choices=list(CATEGORY_MAP.keys()), help="Category (default: anime)")
    parser.add_argument("--select", action="store_true", help="Enable interactive selection by number")
    parser.add_argument("--add", action="store_true", help="After selection, add magnet to aria2 automatically")
    parser.add_argument("--pick", type=int, metavar="N", help="Non-interactive: pick Nth torrent (1-indexed) and show magnet")
    parser.add_argument("--max-size", metavar="SIZE", help="Filter: only show torrents with size <= SIZE (e.g., 1G, 500M, 2GB)")
    args = parser.parse_args()

    torrents = fetch_top(category=args.category, limit=args.limit)
    if not torrents:
        print("No torrents found.", file=sys.stderr)
        sys.exit(1)

    # Apply size filter if provided
    if args.max_size:
        max_bytes = parse_size(args.max_size)
        original_count = len(torrents)
        torrents = [t for t in torrents if t['size'] <= max_bytes]
        if not torrents:
            print(f"No torrents found under {args.max_size} (≤ {max_bytes:,} bytes). Try a larger limit or different category.", file=sys.stderr)
            sys.exit(1)
        # If filtering reduced count, note it in the listing header later

    # If --pick is used, directly output the chosen torrent's info
    if args.pick:
        idx = args.pick - 1
        if idx < 0 or idx >= len(torrents):
            print(f"Error: pick number must be between 1 and {len(torrents)}", file=sys.stderr)
            sys.exit(1)
        selected = torrents[idx]
        print(f"Selected #{args.pick}: {selected['title']}")
        print(f"Size: {selected['size_str']} | Seeds: {selected['seeds']} | Leeches: {selected['leeches']} | Downloads: {selected['downloads']}")
        print(f"Magnet: {selected['magnet']}")
        if args.add:
            # Add to aria2 via RPC
            RPC_SECRET = "openclaw_secret_123"
            RPC_URL = "http://localhost:6800/jsonrpc"
            payload = {"jsonrpc":"2.0","id":"1","method":"aria2.addUri","params":[f"token:{RPC_SECRET}",[selected['magnet']]]}
            try:
                r = requests.post(RPC_URL, json=payload, timeout=5)
                if r.status_code == 200 and r.json().get('result'):
                    print("✓ Added to aria2 download queue.")
                else:
                    print(f"⚠ Failed to add: {r.text}", file=sys.stderr)
            except Exception as e:
                print(f"⚠ RPC error: {e}", file=sys.stderr)
        sys.exit(0)

    # Display numbered list (full mode)
    print(f"Top {len(torrents)} torrents (sorted by seeds):\n")
    for i, t in enumerate(torrents, 1):
        print(f"{i:2}. {t['title'][:60]}{'...' if len(t['title'])>60 else ''}")
        print(f"    Seeds: {t['seeds']} | Leeches: {t['leeches']} | Size: {t['size_str']} | Downloads: {t['downloads']}")
        print()

    if args.select:
        try:
            choice = input("Enter number to select (or 'q' to quit): ").strip()
            if choice.lower() == 'q':
                sys.exit(0)
            idx = int(choice) - 1
            if idx < 0 or idx >= len(torrents):
                print("Invalid selection", file=sys.stderr)
                sys.exit(1)
            selected = torrents[idx]
            print(f"\nSelected: {selected['title']}")
            print(f"Magnet: {selected['magnet']}")
            if args.add:
                # Add to aria2 via RPC
                RPC_SECRET = "openclaw_secret_123"
                RPC_URL = "http://localhost:6800/jsonrpc"
                payload = {"jsonrpc":"2.0","id":"1","method":"aria2.addUri","params":[f"token:{RPC_SECRET}",[selected['magnet']]]}
                try:
                    r = requests.post(RPC_URL, json=payload, timeout=5)
                    if r.status_code == 200 and r.json().get('result'):
                        print("✓ Added to aria2 download queue.")
                    else:
                        print(f"⚠ Failed to add: {r.text}", file=sys.stderr)
                except Exception as e:
                    print(f"⚠ RPC error: {e}", file=sys.stderr)
            else:
                # Output magnet for piping
                print(f"\nMagnet link ready. Use: quick torrent-add \"{selected['magnet']}\"")
        except (ValueError, KeyboardInterrupt):
            print("\nCancelled.")
            sys.exit(0)

if __name__ == "__main__":
    main()
