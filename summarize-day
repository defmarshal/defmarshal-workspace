#!/usr/bin/env python3
"""
Automated daily memory summarization with structured output (Generative Ontology).

Reads daily memory in either:
- JSONL format (memory/YYYY-MM-DD.jsonl) with entries: {"timestamp", "category", "message", "tags?"}
- Or legacy markdown (memory/YYYY-MM-DD.md) with bullet points

Generates:
1. Markdown summary (appended to the .md file)
2. JSON summary report (memory/YYYY-MM-DD-summary.json) for downstream tools
"""

import os
import sys
import json
import argparse
from datetime import datetime
import pytz

WORKSPACE = "/home/ubuntu/.openclaw/workspace"
MEMORY_DIR = os.path.join(WORKSPACE, "memory")

# Category definitions (for classification when reading legacy markdown)
CATEGORIES = {
    'decisions': ['decided', 'choose', 'chose', 'selected', 'opted', 'instead', 'rather', 'go with', 'abandon', 'cancel', 'reject', 'scrap', 'scrapped', 'paused', 'stopped', 'killed', 'deferred', 'postponed', 'dropped'],
    'learnings': ['learned', 'discovered', 'found', 'note', 'remember', 'fact', 'realized', 'understanding', 'insight', 'key', 'important', 'don\'t forget', 'must remember', 'should remember', 'figuring', 'figured out'],
    'tools': ['installed', 'added', 'configured', 'set up', 'skill', 'tool', 'library', 'package', 'npm', 'pip', 'apt', 'brew', 'yum', 'download', 'clone', 'git clone', 'enabled', 'disabled', 'updated', 'upgraded', 'removed', 'uninstalled'],
    'projects': ['built', 'created', 'implemented', 'developed', 'started', 'initiated', 'finished', 'completed', 'shipped', 'deployed', 'released', 'designed', 'architected', 'prototyped', 'made', 'wrote', 'coded', 'refactored', 'restructured', 'organized', 'documented', 'tested', 'fixed', 'debugged'],
    'events': ['meeting', 'call', 'appointment', 'event', 'holiday', 'birthday', 'anniversary', 'conference', 'webinar', 'session', 'run', 'test', 'demo', 'presentation', 'interview', 'deadline', 'schedule', 'planned'],
}

def get_date_str(date=None, tz_name='Asia/Bangkok'):
    tz = pytz.timezone(tz_name)
    if date is None:
        date = datetime.now(tz)
    else:
        if date.tzinfo is None:
            date = tz.localize(date)
        else:
            date = date.astimezone(tz)
    return date.strftime("%Y-%m-%d")

def load_jsonl_entries(date_str):
    path = os.path.join(MEMORY_DIR, f"{date_str}.jsonl")
    entries = []
    if os.path.exists(path):
        with open(path, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        entry = json.loads(line)
                        entries.append(entry)
                    except json.JSONDecodeError:
                        continue
    return entries

def load_markdown_bullets(date_str):
    path = os.path.join(MEMORY_DIR, f"{date_str}.md")
    bullets = []
    if os.path.exists(path):
        with open(path, 'r') as f:
            for line in f:
                stripped = line.strip()
                if stripped.startswith('- ') or stripped.startswith('* '):
                    bullets.append(stripped[2:].strip())
    return bullets

def categorize_text(text):
    text_lower = text.lower()
    for cat, keywords in CATEGORIES.items():
        if any(kw in text_lower for kw in keywords):
            return cat
    return 'other'

def summarize_jsonl_entries(entries):
    categorized = {cat: [] for cat in CATEGORIES.keys()}
    categorized['other'] = []
    for entry in entries:
        msg = entry.get('message', '')
        cat = entry.get('category')  # Prefer explicit category if present
        if not cat:
            cat = categorize_text(msg)
        categorized[cat].append(entry)
    return categorized

def summarize_markdown_bullets(bullets):
    categorized = {cat: [] for cat in CATEGORIES.keys()}
    categorized['other'] = []
    for bullet in bullets:
        cat = categorize_text(bullet)
        categorized[cat].append({'message': bullet, 'category': cat, 'timestamp': None, 'tags': []})
    return categorized

def build_summary_markdown(date_str, categorized):
    lines = []
    lines.append(f"## Daily Summary {date_str}")
    lines.append("")
    lines.append("### Overview")
    total = sum(len(v) for v in categorized.values())
    lines.append(f"- Total entries: {total}")
    for cat in ['decisions', 'learnings', 'tools', 'projects', 'events']:
        count = len(categorized[cat])
        if count:
            lines.append(f"- {cat.capitalize()}: {count}")
    other_count = len(categorized['other'])
    if other_count:
        lines.append(f"- Other: {other_count}")
    lines.append("")
    
    section_titles = {
        'decisions': 'Key Decisions',
        'learnings': 'Learnings',
        'tools': 'Tools & Skills Added/Updated',
        'projects': 'Projects Progress',
        'events': 'Events & Milestones',
        'other': 'Other Notable Items'
    }
    
    for cat in ['decisions', 'learnings', 'tools', 'projects', 'events', 'other']:
        items = categorized[cat]
        if items:
            lines.append(f"### {section_titles[cat]}")
            for item in items:
                msg = item.get('message', '')
                lines.append(f"- {msg}")
            lines.append("")
    
    return "\n".join(lines)

def build_summary_json(date_str, categorized):
    summary = {
        "date": date_str,
        "generatedAt": datetime.utcnow().isoformat() + "Z",
        "overview": {
            "total": sum(len(v) for v in categorized.values()),
            "byCategory": {cat: len(categorized[cat]) for cat in CATEGORIES.keys()}
        },
        "entries": {}
    }
    for cat, items in categorized.items():
        summary["entries"][cat] = [
            {
                "message": item.get("message", ""),
                "timestamp": item.get("timestamp"),
                "tags": item.get("tags", [])
            }
            for item in items
        ]
    return summary

def append_markdown_summary(date_str, summary_md):
    path = os.path.join(MEMORY_DIR, f"{date_str}.md")
    with open(path, 'a') as f:
        f.write("\n" + summary_md + "\n")
    return path

def write_json_summary(date_str, summary_json):
    path = os.path.join(MEMORY_DIR, f"{date_str}-summary.json")
    with open(path, 'w') as f:
        json.dump(summary_json, f, indent=2)
    return path

def main():
    parser = argparse.ArgumentParser(description='Generate daily memory summary (markdown + JSON)')
    parser.add_argument('date', nargs='?', help='Date to summarize (YYYY-MM-DD). Default: today (Asia/Bangkok).')
    args = parser.parse_args()
    
    if args.date:
        try:
            date_str = args.date
            datetime.strptime(date_str, '%Y-%m-%d')
        except ValueError:
            print(f"Error: Invalid date format: {args.date}. Use YYYY-MM-DD.", file=sys.stderr)
            sys.exit(1)
    else:
        date_str = get_date_str()
    
    # Prefer JSONL if exists, else fall back to markdown bullet extraction
    jsonl_entries = load_jsonl_entries(date_str)
    if jsonl_entries:
        categorized = summarize_jsonl_entries(jsonl_entries)
    else:
        bullets = load_markdown_bullets(date_str)
        if not bullets:
            print(f"No memory entries found for {date_str}. Nothing to summarize.", file=sys.stderr)
            sys.exit(0)
        categorized = summarize_markdown_bullets(bullets)
    
    # Build summaries
    summary_md = build_summary_markdown(date_str, categorized)
    summary_json = build_summary_json(date_str, categorized)
    
    # Write outputs
    md_path = append_markdown_summary(date_str, summary_md)
    json_path = write_json_summary(date_str, summary_json)
    
    print(f"Markdown summary appended to {md_path}")
    print(f"JSON summary written to {json_path}")
    print("\n--- Summary Preview ---\n")
    print(summary_md)

if __name__ == '__main__':
    main()
