#!/usr/bin/env node
/**
 * ClawDash Backend Server
 * - Serves the PWA from apps/dashboard/
 * - POST /api/send        â†’ sends message to mewmew via openclaw agent
 * - POST /api/quick       â†’ runs ./quick <cmd> safely
 * - GET  /api/data        â†’ returns latest data.json (regenerated on demand)
 * - GET  /api/chat        â†’ returns chat messages from current telegram session
 * - GET  /api/vapid-key   â†’ returns VAPID public key for push subscription
 * - POST /api/subscribe   â†’ saves push subscription
 * - GET  /api/tokens      â†’ token usage aggregated per cron job (last 7 days)
 * - POST /api/notify-test â†’ send test push notification
 */

const http  = require('http');
const https = require('https');
const fs    = require('fs');
const path  = require('path');
const { spawn, execFile } = require('child_process');

const PORT       = 3001;
const HTTPS_PORT = 3443;
const HOST       = '0.0.0.0';
const WORKSPACE     = path.join(process.env.HOME, '.openclaw', 'workspace');
const DASHBOARD_DIR = path.join(WORKSPACE, 'apps', 'dashboard');
const DATA_JSON     = path.join(DASHBOARD_DIR, 'data.json');
const SESSIONS_JSON = path.join(process.env.HOME, '.openclaw', 'agents', 'main', 'sessions', 'sessions.json');
const SESSIONS_DIR  = path.join(process.env.HOME, '.openclaw', 'agents', 'main', 'sessions');
const CERT_PATH     = path.join(DASHBOARD_DIR, 'tls.crt');
const KEY_PATH      = path.join(DASHBOARD_DIR, 'tls.key');
const VAPID_PATH    = path.join(DASHBOARD_DIR, 'vapid.json');
const SUBS_PATH     = path.join(DASHBOARD_DIR, 'push-subscriptions.json');
const CRON_JOBS_JSON = path.join(process.env.HOME, '.openclaw', 'cron', 'jobs.json');
const CRON_RUNS_DIR  = path.join(process.env.HOME, '.openclaw', 'cron', 'runs');

// â”€â”€ VAPID / web-push setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let webPush = null;
let vapid = null;
try {
  webPush = require(path.join(WORKSPACE, 'node_modules', 'web-push'));
  vapid = JSON.parse(fs.readFileSync(VAPID_PATH, 'utf8'));
  webPush.setVapidDetails(vapid.subject, vapid.publicKey, vapid.privateKey);
  console.log('ðŸ”” Push notifications ready');
} catch (e) {
  console.warn('âš ï¸  web-push not available:', e.message);
}

// â”€â”€ Subscription store â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadSubs() {
  try { return JSON.parse(fs.readFileSync(SUBS_PATH, 'utf8')); } catch { return []; }
}
function saveSubs(subs) {
  fs.writeFileSync(SUBS_PATH, JSON.stringify(subs, null, 2));
}
function addSub(sub) {
  const subs = loadSubs();
  const exists = subs.some(s => s.endpoint === sub.endpoint);
  if (!exists) { subs.push(sub); saveSubs(subs); }
}

async function sendPushToAll(payload) {
  if (!webPush) return;
  const subs = loadSubs();
  if (!subs.length) return;
  const dead = [];
  for (const sub of subs) {
    try {
      await webPush.sendNotification(sub, JSON.stringify(payload));
    } catch (e) {
      if (e.statusCode === 410 || e.statusCode === 404) dead.push(sub.endpoint);
      else console.warn('push failed:', e.message);
    }
  }
  if (dead.length) saveSubs(subs.filter(s => !dead.includes(s.endpoint)));
}

// â”€â”€ Allowed quick commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ALLOWED_QUICK = new Set([
  'health', 'status', 'summary', 'dash', 'agents-summary', 'log-tail',
  'top-commits', 'mem', 'memory-status', 'memory-dirty', 'memory-stats',
  'heartbeat-state', 'hygiene', 'cron', 'cron-status', 'cron-failures',
  'gateway-status', 'gateway-info', 'daemons', 'agent-status', 'dev-log',
  'today', 'git-status', 'git-today', 'git-summary', 'git-last',
  'downloads', 'torrent-status', 'updates-check', 'voyage-status',
  'orphan-check', 'checkpoints', 'phase', 'reports', 'digest',
  'health-snapshot', 'vercel-status', 'validate', 'verify',
  'supervisor-logs', 'meta-logs', 'meta-report',
]);

const MIME = {
  '.html': 'text/html', '.js': 'application/javascript', '.css': 'text/css',
  '.json': 'application/json', '.svg': 'image/svg+xml', '.png': 'image/png',
  '.ico': 'image/x-icon', '.webp': 'image/webp',
  '.webmanifest': 'application/manifest+json',
};

function cors(res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,DELETE,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
}
function json(res, code, obj) {
  cors(res);
  res.writeHead(code, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify(obj));
}
function readBody(req) {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', d => { body += d; if (body.length > 65536) reject(new Error('body too large')); });
    req.on('end', () => { try { resolve(JSON.parse(body)); } catch { resolve({}); } });
    req.on('error', reject);
  });
}
function run(cmd, args, opts = {}) {
  return new Promise((resolve) => {
    execFile(cmd, args, { timeout: 30000, cwd: WORKSPACE, ...opts }, (err, stdout, stderr) => {
      resolve({ ok: !err, stdout: stdout || '', stderr: stderr || '', code: err?.code || 0 });
    });
  });
}

async function regenerateData() {
  return run('bash', [path.join(WORKSPACE, 'scripts', 'generate-dashboard-data.sh')]);
}

function getChatHistory() {
  try {
    const sessions = JSON.parse(fs.readFileSync(SESSIONS_JSON, 'utf8'));
    const sessionId = sessions['agent:main:telegram:direct:952170974']?.sessionId;
    if (!sessionId) return [];
    const sessionFile = path.join(SESSIONS_DIR, sessionId + '.jsonl');
    if (!fs.existsSync(sessionFile)) return [];
    const msgs = [];
    for (const line of fs.readFileSync(sessionFile, 'utf8').split('\n')) {
      if (!line.trim()) continue;
      try {
        const m = JSON.parse(line);
        if (m.type !== 'message') continue;
        const msg = m.message;
        const role = msg.role;
        if (!['user', 'assistant'].includes(role)) continue;
        let text = '';
        if (Array.isArray(msg.content)) {
          text = msg.content.filter(c => c.type === 'text').map(c => c.text).join(' ');
        } else { text = String(msg.content || ''); }
        if (role === 'user' && text.includes('Conversation info')) {
          const end = text.indexOf('```\n\n');
          if (end >= 0) text = text.slice(end + 5).trim();
        }
        if (!text.trim()) continue;
        // Filter out system/meta messages
        if (text === 'HEARTBEAT_OK') continue;
        if (text.startsWith('[System Message]')) continue;
        if (text.startsWith('Read HEARTBEAT')) continue;
        if (text.startsWith('Pre-compaction memory flush')) continue;
        if (text.startsWith('NO_REPLY')) continue;
        if (text.includes('Conversation info (untrusted metadata)')) continue;
        if (text.startsWith('Continue') && text.length < 20) continue;
        if (text.startsWith('Continueeee')) continue;
        if (role === 'assistant' && text === 'NO_REPLY') continue;
        if (text.length < 2) continue;
        msgs.push({ role, ts: m.timestamp, text });
      } catch {}
    }
    return msgs.slice(-100);
  } catch { return []; }
}

// â”€â”€ Chat watcher â€” push notification on new assistant message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastAssistantMsgCount = 0;
function startChatWatcher() {
  setInterval(() => {
    const msgs = getChatHistory();
    const assistantCount = msgs.filter(m => m.role === 'assistant').length;
    if (lastAssistantMsgCount > 0 && assistantCount > lastAssistantMsgCount) {
      const latest = msgs.filter(m => m.role === 'assistant').pop();
      const preview = (latest?.text || '').slice(0, 100).replace(/\n/g, ' ');
      sendPushToAll({
        title: 'ðŸ¾ mewmew replied!',
        body: preview || 'New message in ClawDash',
        url: '/?tab=chat',
        tag: 'clawdash-reply',
      }).catch(() => {});
    }
    if (assistantCount !== lastAssistantMsgCount) broadcastChat(msgs);
    lastAssistantMsgCount = assistantCount;
  }, 5000); // check every 5s
}

// â”€â”€ aria2 torrent status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ARIA2_URL = 'http://localhost:6800/jsonrpc';
const ARIA2_TOKEN = 'token:openclaw_secret_123';

async function aria2Call(method, params = []) {
  try {
    const body = JSON.stringify({ jsonrpc: '2.0', method, id: '1', params: [ARIA2_TOKEN, ...params] });
    const res = await fetch(ARIA2_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
    const d = await res.json();
    return d.result || [];
  } catch { return []; }
}
function fmtBytes(n) {
  n = parseInt(n) || 0;
  if (n > 1e9) return (n/1e9).toFixed(1) + ' GB';
  if (n > 1e6) return (n/1e6).toFixed(1) + ' MB';
  if (n > 1e3) return (n/1e3).toFixed(1) + ' KB';
  return n + ' B';
}
async function getTorrentStatus() {
  const fields = ['gid','status','totalLength','completedLength','downloadSpeed','uploadSpeed','files','bittorrent','numSeeders','errorMessage'];
  const [active, waiting, stopped] = await Promise.all([
    aria2Call('aria2.tellActive', [fields]),
    aria2Call('aria2.tellWaiting', [0, 10, fields]),
    aria2Call('aria2.tellStopped', [0, 5, fields]),
  ]);
  const fmt = items => items.map(it => {
    const name = it.bittorrent?.info?.name || it.files?.[0]?.path?.split('/').pop() || it.gid;
    const total = parseInt(it.totalLength) || 0;
    const done = parseInt(it.completedLength) || 0;
    const pct = total > 0 ? Math.round(done / total * 100) : 0;
    return {
      gid: it.gid, name, status: it.status, pct,
      speed_dn: fmtBytes(it.downloadSpeed) + '/s',
      speed_up: fmtBytes(it.uploadSpeed) + '/s',
      size: fmtBytes(total), seeders: parseInt(it.numSeeders) || 0,
      error: it.errorMessage || null,
    };
  });
  return { active: fmt(active), waiting: fmt(waiting), stopped: fmt(stopped) };
}

// â”€â”€ Token usage aggregation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getTokenStats() {
  try {
    // Load cron jobs to get idâ†’name mapping
    const cronData = JSON.parse(fs.readFileSync(CRON_JOBS_JSON, 'utf8'));
    const jobs = cronData.jobs || [];
    const idToName = {};
    for (const j of jobs) idToName[j.id] = j.name || j.id;

    const cutoff = Date.now() - 7 * 24 * 60 * 60 * 1000; // 7 days ago
    const todayCutoff = new Date();
    todayCutoff.setUTCHours(0, 0, 0, 0);

    // Aggregate from session JSONL files
    // sessions.json maps "agent:main:cron:<cronId>" -> { sessionId }
    const sessionsMap = JSON.parse(fs.readFileSync(SESSIONS_JSON, 'utf8'));

    // Build cronId -> latest sessionId map
    const cronSessions = {};
    for (const [key, val] of Object.entries(sessionsMap)) {
      const m = key.match(/^agent:main:cron:([^:]+)$/);
      if (m) cronSessions[m[1]] = val.sessionId;
    }

    // Also scan runs/ JSONL files (one per job, contains run records with durationMs)
    // For token data we need the session JSONL files
    const stats = {}; // cronId -> { name, total_in, total_out, total_cache_read, total_cache_write, runs, last_run_ms }

    // Walk all sessions in sessions.json, not just current ones â€” scan all JSONL files
    // that correspond to cron sessions. The session file may have rotated but we scan all.
    const allKeys = Object.entries(sessionsMap);
    for (const [key, val] of allKeys) {
      const m = key.match(/^agent:main:cron:([^:]+)$/);
      if (!m) continue;
      const cronId = m[1];
      const sessionId = val.sessionId;
      if (!sessionId) continue;
      const sessionFile = path.join(SESSIONS_DIR, sessionId + '.jsonl');
      if (!fs.existsSync(sessionFile)) continue;

      // Read session file and sum usage
      let totalIn = 0, totalOut = 0, totalCacheRead = 0, totalCacheWrite = 0;
      let runCount = 0, lastTs = 0;
      const lines = fs.readFileSync(sessionFile, 'utf8').split('\n');
      for (const line of lines) {
        if (!line.trim()) continue;
        try {
          const obj = JSON.parse(line);
          if (obj.type !== 'message') continue;
          const ts = obj.timestamp ? new Date(obj.timestamp).getTime() : 0;
          if (ts < cutoff) continue;
          const usage = obj.message?.usage;
          if (!usage) continue;
          const inp = usage.input || 0;
          const out = usage.output || 0;
          if (inp === 0 && out === 0) continue;
          totalIn += inp;
          totalOut += out;
          totalCacheRead += usage.cacheRead || 0;
          totalCacheWrite += usage.cacheWrite || 0;
          runCount++;
          if (ts > lastTs) lastTs = ts;
        } catch {}
      }
      if (runCount === 0 && totalIn === 0) continue;

      const name = idToName[cronId] || `cron-${cronId.slice(0, 8)}`;
      if (!stats[cronId]) {
        stats[cronId] = { id: cronId, name, total_in: 0, total_out: 0, total_cache_read: 0, total_cache_write: 0, runs: 0, last_run_ms: 0 };
      }
      stats[cronId].total_in += totalIn;
      stats[cronId].total_out += totalOut;
      stats[cronId].total_cache_read += totalCacheRead;
      stats[cronId].total_cache_write += totalCacheWrite;
      stats[cronId].runs += runCount;
      if (lastTs > stats[cronId].last_run_ms) stats[cronId].last_run_ms = lastTs;
    }

    // Also check runs JSONL for more accurate run counts if above is thin
    // (runs dir has one file per job, each line is a run record)
    if (fs.existsSync(CRON_RUNS_DIR)) {
      for (const fname of fs.readdirSync(CRON_RUNS_DIR)) {
        if (!fname.endsWith('.jsonl')) continue;
        const cronId = fname.replace('.jsonl', '');
        if (!stats[cronId]) continue; // only enrich jobs we already have
        const runsFile = path.join(CRON_RUNS_DIR, fname);
        let runCount = 0, lastTs = 0;
        const lines = fs.readFileSync(runsFile, 'utf8').split('\n');
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const obj = JSON.parse(line);
            if (obj.action !== 'finished') continue;
            const ts = obj.ts || 0;
            if (ts < cutoff) continue;
            runCount++;
            if (ts > lastTs) lastTs = ts;
          } catch {}
        }
        // Use max of both counting methods
        if (runCount > stats[cronId].runs) stats[cronId].runs = runCount;
        if (lastTs > stats[cronId].last_run_ms) stats[cronId].last_run_ms = lastTs;
      }
    }

    // Compute today's totals
    let todayTotalIn = 0, todayTotalOut = 0;
    let weekTotalIn = 0, weekTotalOut = 0;
    const rows = Object.values(stats).map(s => {
      const total = s.total_in + s.total_out;
      const avg = s.runs > 0 ? Math.round(total / s.runs) : 0;
      weekTotalIn += s.total_in;
      weekTotalOut += s.total_out;
      return {
        id: s.id,
        name: s.name,
        runs: s.runs,
        total_in: s.total_in,
        total_out: s.total_out,
        total_cache_read: s.total_cache_read,
        total: total,
        avg_tokens: avg,
        last_run_ms: s.last_run_ms,
      };
    });
    rows.sort((a, b) => b.total - a.total);

    return {
      ok: true,
      week: { total_in: weekTotalIn, total_out: weekTotalOut, total: weekTotalIn + weekTotalOut },
      rows,
    };
  } catch (e) {
    return { ok: false, error: e.message, rows: [] };
  }
}

// â”€â”€ SSE â€” chat stream â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sseClients = new Set();
function broadcastChat(msgs) {
  const data = 'data: ' + JSON.stringify({ chat: msgs }) + '\n\n';
  for (const client of sseClients) {
    try { client.write(data); } catch { sseClients.delete(client); }
  }
}

// â”€â”€ Request handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const handler = async (req, res) => {
  const url = new URL(req.url, `https://${req.headers.host}`);
  const pathname = url.pathname;

  if (req.method === 'OPTIONS') { cors(res); res.writeHead(204); res.end(); return; }

  // â”€â”€ VAPID public key â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/vapid-key' && req.method === 'GET') {
    return json(res, 200, { publicKey: vapid?.publicKey || null });
  }

  // â”€â”€ Save push subscription â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/subscribe' && req.method === 'POST') {
    const body = await readBody(req);
    if (!body.endpoint) return json(res, 400, { error: 'invalid subscription' });
    addSub(body);
    console.log('New push subscriber:', body.endpoint.slice(0, 60) + 'â€¦');
    return json(res, 200, { ok: true });
  }

  // â”€â”€ Test push notification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/torrents') {
    const t = await getTorrentStatus();
    cors(res); res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(t));
    return;
  }

  // SSE chat stream
  if (pathname === '/api/chat-stream') {
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
    });
    res.write(': connected\n\n');
    // Send current chat immediately
    res.write('data: ' + JSON.stringify({ chat: getChatHistory() }) + '\n\n');
    sseClients.add(res);
    req.on('close', () => sseClients.delete(res));
    return;
  }

  if (pathname === '/api/notify-test' && req.method === 'POST') {
    await sendPushToAll({ title: 'ðŸ¦¾ ClawDash test', body: 'Push notifications are working! nyaa~', url: '/', tag: 'test' });
    return json(res, 200, { ok: true, subs: loadSubs().length });
  }

  // â”€â”€ Send message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/send' && req.method === 'POST') {
    const body = await readBody(req);
    const message = (body.message || '').trim();
    if (!message) return json(res, 400, { error: 'message required' });
    let sessionId = null;
    try {
      const sessions = JSON.parse(fs.readFileSync(SESSIONS_JSON, 'utf8'));
      sessionId = sessions['agent:main:telegram:direct:952170974']?.sessionId;
    } catch {}
    if (!sessionId) return json(res, 500, { ok: false, error: 'Could not resolve session ID' });
    const proc = spawn('openclaw', ['agent', '--session-id', sessionId, '--message', message, '--deliver'],
      { detached: true, stdio: 'ignore', cwd: WORKSPACE });
    proc.unref();
    return json(res, 200, { ok: true, output: 'Message queued â€” reply coming via Telegram' });
  }

  // â”€â”€ Quick command â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/quick' && req.method === 'POST') {
    const body = await readBody(req);
    const parts = (body.cmd || '').trim().split(/\s+/);
    const cmd = parts[0], args = parts.slice(1);
    if (!ALLOWED_QUICK.has(cmd))
      return json(res, 403, { error: `command '${cmd}' not allowed` });
    const result = await run(path.join(WORKSPACE, 'quick'), [cmd, ...args]);
    return json(res, 200, { ok: result.ok, output: (result.stdout + result.stderr).trim() });
  }

  // â”€â”€ Data (live) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/data' && req.method === 'GET') {
    await regenerateData();
    try {
      const data = JSON.parse(fs.readFileSync(DATA_JSON, 'utf8'));
      data.chat = getChatHistory();
      data.push_enabled = webPush !== null;
      return json(res, 200, data);
    } catch (e) { return json(res, 500, { error: e.message }); }
  }

  // â”€â”€ Chat only (fast) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/chat' && req.method === 'GET') {
    return json(res, 200, { chat: getChatHistory() });
  }

  // â”€â”€ Token usage stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/tokens' && req.method === 'GET') {
    return json(res, 200, getTokenStats());
  }

  // â”€â”€ Downloads list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/downloads-list' && req.method === 'GET') {
    const dlDir = path.join(WORKSPACE, 'downloads');
    try {
      const getFiles = (dir, base='') => {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        let files = [];
        for (const e of entries) {
          const rel = base ? `${base}/${e.name}` : e.name;
          const abs = path.join(dir, e.name);
          if (e.isDirectory()) files = files.concat(getFiles(abs, rel));
          else {
            const st = fs.statSync(abs);
            files.push({ name: e.name, path: rel, size: st.size, mtime: st.mtimeMs });
          }
        }
        return files;
      };
      const files = getFiles(dlDir).sort((a,b) => b.size - a.size);
      const total = files.reduce((s,f) => s+f.size, 0);
      cors(res);
      return json(res, 200, { ok: true, files, total });
    } catch(e) {
      return json(res, 200, { ok: false, files: [], total: 0, error: e.message });
    }
  }

  // â”€â”€ Projects overview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname === '/api/projects' && req.method === 'GET') {
    try {
      const projects = [];
      const projectDirs = [
        { dir: 'games/anime-studio-tycoon', name: 'Anime Studio Tycoon', icon: '\uD83C\uDFAE' },
        { dir: 'research', name: 'Research Hub', icon: '\uD83D\uDCD6' },
        { dir: 'apps/dashboard', name: 'ClawDash', icon: '\uD83D\uDCCA' },
        { dir: 'docs', name: 'Documentation', icon: '\uD83D\uDCD4' },
        { dir: 'skills', name: 'OpenClaw Skills', icon: '\uD83D\uDD27' },
      ];

      for (const p of projectDirs) {
        if (!/^[a-z0-9\/_-]+$/i.test(p.dir)) {
          console.warn(`Skipping invalid project dir pattern: ${p.dir}`);
          continue;
        }
        const fullPath = path.normalize(path.join(WORKSPACE, p.dir));
        if (!fullPath.startsWith(WORKSPACE)) {
          console.warn(`Skipping path outside workspace: ${p.dir}`);
          continue;
        }
        if (!fs.existsSync(fullPath)) continue;

        let lastCommit = null;
        try {
          const gitLog = execFileSync('git', ['-C', fullPath, 'log', '-1', '--pretty=format:%H|%s|%cI'], { encoding: 'utf8', maxBuffer: 1024 * 1024 }).trim();
          if (gitLog) {
            const [hash, message, date] = gitLog.split('|');
            lastCommit = { hash, message, date };
          }
        } catch (e) { console.warn(`git log failed for ${p.dir}:`, e.message); }

        let status = 'idle';
        try {
          const gitStatus = execFileSync('git', ['-C', fullPath, 'status', '--porcelain'], { encoding: 'utf8', maxBuffer: 1024 * 1024 }).trim();
          if (gitStatus) status = 'active';
        } catch (e) { console.warn(`git status failed for ${p.dir}:`, e.message); }

        let description = '';
        try {
          const readmePath = path.join(fullPath, 'README.md');
          if (fs.existsSync(readmePath)) {
            const readme = fs.readFileSync(readmePath, 'utf8');
            const firstLine = readme.split('\n')[0].trim();
            description = firstLine.replace(/^#+\s*/, '').replace(/<[^>]*>/g, '').trim();
          }
        } catch (e) { console.warn(`README read failed for ${p.dir}:`, e.message); }

        projects.push({
          name: p.name,
          icon: p.icon,
          description: description || `${p.name} project`,
          path: p.dir,
          status,
          lastCommit,
        });
      }

      cors(res);
      return json(res, 200, { ok: true, projects });
    } catch (e) {
      console.error('Projects API error:', e.message);
      return json(res, 500, { ok: false, error: e.message });
    }
  }

  // â”€â”€ Download a file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname.startsWith('/api/download/') && req.method === 'GET') {
    const rel = decodeURIComponent(pathname.slice('/api/download/'.length));
    if (rel.includes('..')) return json(res, 400, { error: 'invalid path' });
    const abs = path.join(WORKSPACE, 'downloads', rel);
    if (!abs.startsWith(path.join(WORKSPACE, 'downloads'))) return json(res, 403, { error: 'forbidden' });
    try {
      const st = fs.statSync(abs);
      const fname = path.basename(abs);
      cors(res);
      res.writeHead(200, {
        'Content-Type': 'application/octet-stream',
        'Content-Disposition': `attachment; filename*=UTF-8''${encodeURIComponent(fname)}`,
        'Content-Length': st.size,
      });
      fs.createReadStream(abs).pipe(res);
    } catch(e) {
      return json(res, 404, { error: 'not found' });
    }
    return;
  }

  // â”€â”€ Delete a download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (pathname.startsWith('/api/download/') && req.method === 'DELETE') {
    const rel = decodeURIComponent(pathname.slice('/api/download/'.length));
    if (rel.includes('..')) return json(res, 400, { error: 'invalid path' });
    const abs = path.join(WORKSPACE, 'downloads', rel);
    if (!abs.startsWith(path.join(WORKSPACE, 'downloads'))) return json(res, 403, { error: 'forbidden' });
    try {
      fs.rmSync(abs, { recursive: true, force: true });
      // Remove parent dir if empty
      const parent = path.dirname(abs);
      if (parent !== path.join(WORKSPACE, 'downloads')) {
        const remaining = fs.readdirSync(parent);
        if (remaining.length === 0) fs.rmdirSync(parent);
      }
      cors(res);
      return json(res, 200, { ok: true });
    } catch(e) {
      return json(res, 500, { error: e.message });
    }
  }


